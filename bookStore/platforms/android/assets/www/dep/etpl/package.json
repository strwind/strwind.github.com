{
  "name": "etpl",
  "version": "2.1.0-rc",
  "contributors": [
    {
      "name": "erik",
      "email": "errorrik@gmail.com"
    },
    {
      "name": "otakustay",
      "email": "otakustay@gmail.com"
    },
    {
      "name": "firede",
      "email": "firede@firede.us"
    }
  ],
  "main": "main",
  "homepage": "http://ecomfe.github.io/etpl/",
  "repository": {
    "type": "git",
    "url": "git://github.com/ecomfe/etpl"
  },
  "description": "ETPL是一个灵活、具有强大复用能力的高性能Javascript模板引擎，适用于WEB前端应用中视图的生成，特别是SPA(Single Page APP)类型的应用。",
  "scripts": {
    "test": "jasmine-node test/spec"
  },
  "devDependencies": {
    "jasmine-node": "~1.14.2"
  },
  "readme": "# ETPL (Enterprise Template)\n\n[![Build Status](https://travis-ci.org/ecomfe/etpl.svg?branch=master)](https://travis-ci.org/ecomfe/etpl)\n\nETPL是一个灵活、具有强大复用能力的高性能的模板引擎，适用于WEB前端应用中视图的生成，特别是SPA(Single Page APP)类型的应用。\n\n- [开始](#start)\n- [了解ETPL的语法](#syntax)\n    - [基础](#基础)\n        - [语法形式](#语法形式)\n        - [自动结束](#自动结束)\n        - [target](#target)\n        - [变量声明](#变量声明)\n        - [变量替换](#变量替换)\n        - [内容块过滤](#内容块过滤)\n    - [模板复用](#模板复用)\n        - [import](#import)\n        - [母版](#母版)\n        - [use](#use)\n    - [分支与循环](#分支与循环)\n        - [if](#if)\n        - [for](#for)\n- [浏览ETPL的API](#api)\n    - [methods](#methods)\n    - [classes](#classes)\n- [与ER中模板引擎的兼容性](#compatibility)\n\n## Start\n\nETPL可以在`CommonJS/AMD`的模块定义环境中使用，也可以直接在页面下通过`<script src=`的方式引用。`CommonJS/AMD`环境下需要通过如下代码得到ETPL的模块。\n\n```javascript\nvar etpl = require( 'etpl' );\n```\n\n得到ETPL模块对象后，首先对模板源代码进行编译，就能够得到模板编译后的`function`。\n\n```javascript\nvar render = etpl.compile( 'Hello ${name}!' );\n```\n\n然后执行这个`function`，传入数据对象，就能得到模板执行的结果了。\n\n```javascript\nvar text = render( {name: 'etpl'} );\n```\n\n编写模板和数据前，如果对执行结果有疑虑，就去ETPL的[homepage](http://ecomfe.github.io/etpl/)试试看吧。\n\n\n## Syntax\n\n### 基础\n\n#### 语法形式\n\nETPL的指令标签默认为HTML注释的形式，在指令标签内允许声明 `指令起始`、`指令结束`和`注释`。\n\n`指令起始`的语法形式为： *<!-- command-name: command-value -->*。其中， *command-value* 的具体语法形式详情请参见各指令相关章节。\n\n```html\n<!-- target: targetName -->\n<!-- if: ${number} > 0 -->\n<!-- for: ${persons} as ${person}, ${index} -->\n```\n\n`指令结束`的语法形式为： *<!-- /command-name -->*。\n\n```html\n<!-- /if -->\n<!-- /for -->\n<!-- /target -->\n```\n\n`注释`的语法形式为： *<!-- //message -->*，注释指令在render时将不输出。\n\n```html\n<!-- // just add some message -->\n```\n\n如果不期望使用HTML注释形式的指令标签，可以通过config API可以配置指令标签的形式：\n\n```javascript\netpl.config({\n    commandOpen: '<%',\n    commandClose: '%>'\n});\n\n/* \n配置指令标签的形式为“<% ... %>”，然后指令标签可以像下面一样声明:\n<% if: ${number} > 0 %>\ngreater than zero\n<% /if %>\n*/\n```\n\n#### 自动结束\n\n为了减少开发者的工作量，部分指令标签支持`自动结束`，模板开发者无需手工编写`指令结束`。比如：当遇见target指令起始时，ETPL自动认为上一个target已经结束。\n\n具体指令的`自动结束`支持，请参考相应指令相关章节。\n\n\n#### target\n\n`target`是ETPL的基本单元，其含义是 **一个模版片段** 。`target`可用于render，也可用于被其他`target`所import或use。\n\n如果仅仅编写的是一个模板片段，可以省略`target`的声明。这样的编写方式与其他模板引擎类似，ETPL将默认生成匿名target，但模板片段将不可复用（不可被import或use，不可指定母版）。\n\n匿名target应位于模板源码起始。下面例子中，位于其他target后的模板片段`Bye`将没有任何作用。\n\n```\n<!-- use: hello(name=${name}) -->\n<!-- target: hello -->\nHello ${name}!\n<!-- /target -->\nBye\n```\n\n##### 语法\n\ntarget的语法形式为：\n\n    target: target-name\n    target: target-name(master=master-name)\n\ntarget声明可以为其指定相应的母版。母版功能请参考模板复用章节。\n\n\n##### 自动结束\n\ntarget支持自动结束，当遇见 *target* 或 *master* 时自动结束。\n\n\n##### 示例\n\n```html\n<!-- target: hello -->\nHello <strong>ETPL</strong>!\n\n<!-- target: bye -->\nBye <strong>ETPL</strong>!\n```\n\n#### 变量声明\n\n通过`var`指令可以在模板内部声明一个变量。声明的变量在整个`target`内有效。\n\n##### 语法\n\nvar的语法形式为：\n\n    var: var-name=expression\n\n`expression`中可以使用静态或动态数据。\n\n##### 示例\n\n```html\n<!-- var: age = 18 -->\n<!-- var: age = ${person.age} -->\n<!-- var: name = 'etpl' -->\n```\n\n##### 自动结束\n\nvar无需编写`指令结束`，其将在`指令起始`后立即自动结束。\n\n\n#### 变量替换\n\n绝大多数模板引擎都支持变量替换功能。ETPL变量替换的语法为：\n\n    ${variable-name}\n    ${variable-name|filter-name}\n    ${variable-name|filter-name(arguments)}\n    ${variable-name|filter1|filter2(arguments)|filter3|...}\n\nvariable-name支持`.`形式的property access。\n\n编写模板时可以指定filter，默认使用html filter进行HTML转义。如果想要保留变量的原形式，需要手工指定使用名称为raw的filter，或者通过config API配置引擎的defaultFilter参数。\n\n    ${myVariable|raw}\n\n```javascript\netpl.config({ \n    defaultFilter: ''\n});\n```\n\nETPL默认支持3种filters，可以通过引擎的`addFilter`方法自定义扩展filter。\n\n- html: html转义\n- url: url转义\n- raw: 不进行任何转义\n\n\n变量替换支持多filter处理。filter之间以类似管道的方式，前一个filter的输出做为后一个filter的输入，向后传递。\n\n```html\n${myVariable|html|url}\n```\n\nfilter支持参数传递，参数可以使用动态数据。\n\n```html\n<!-- // 假设存在扩展filter: comma -->\n${myVariable|comma(3)}\n${myVariable|comma(${commaLength})}\n${myVariable|comma(${commaLength}+1)}\n```\n\n在变量替换中，引擎会默认将数据toString后传递给filter，以保证filter输入输出的类型一致性。如果filter期望接受的是原始数据，模板开发者需要通过前缀的`*`指定。\n\n```html\n<!-- // 假设存在扩展filter: dateFormat -->\n${*myDate|dateFormat('yyyy-MM-dd')}\n```\n\n#### 内容块过滤\n\n除了在变量替换中可以使用filter进行处理，ETPL还可以通过`filter`指令，使用指定的filter对一个模板内容块进行过滤处理。\n\n##### 语法\n\nfilter的语法形式为：\n\n    filter: filter-name\n    filter: filter-name(arguments)\n\n##### 示例\n\n下面的例子假定使用者实现了一个markdown的filter\n\n```html\n<!-- filter: markdown(${useExtra}, true) -->\n## markdown document\n\nThis is the content, also I can use `${variables}`\n<!-- /filter -->\n```\n\n##### 自动结束\n\nfilter指令不支持自动结束，必须手工编写`指令结束`。\n\n```html\n<!-- /filter -->\n```\n\n### 模板复用\n\nETPL支持多种形式的模板复用方式，帮助模板开发者减少模板编写的重复劳动和维护成本。\n\n\n#### import\n\n通过import指令，可以在当前位置插入指定target的源码。\n\n##### 语法\n\nimport的语法形式为：\n\n    import: target-name\n\n\n##### 示例\n\n```html\n<!-- target: hello -->\nHello <strong>${name}</strong>!\n\n<!-- target: main -->\n<div class=\"main\"><!-- import: hello --></div>\n```\n\n##### 自动结束\n\nimport无需编写`指令结束`，其将在`指令起始`后立即自动结束。\n\n\n#### 母版\n\n通过`master`指令可以声明一个母版，母版中通过`contentplaceholder`指令声明可被替换的部分。\n\n`target`声明时通过 **master=master-name** 指定一个母版，就可以继承于这个母版的片段，并且通过`content`指令，替换母版中`contentplaceholder`指令声明部分的内容。指定母版的target中只允许包含`content`指令声明的片段。\n\n母版功能支持多层母版，`master`声明时也可以通过 **master=master-name** 指定一个母版。母板中的`contentplaceholder`不会再传递下去，即`contentplaceholder`只在一层有效。\n\n##### 语法\n\nmaster的语法形式为：\n\n    master: master-name\n    master: master-name(master=master-name)\n\ncontentplaceholder的语法形式为：\n\n    contentplaceholder: content-name\n\ncontent的语法形式为：\n\n    content: content-name\n\n\n##### 示例\n\n```html\n<!-- master: myMaster -->\n<div class=\"title\"><!-- contentplaceholder: title -->title<!-- /contentplaceholder --></div>\n<div class=\"main\"><!-- contentplaceholder: main --></div>\n\n<!-- master: myMaster-has-sidebar(master=myMaster) -->\n<!-- content: title -->\ntitle for has sidebar\n<!-- content: main -->\n<div class=\"sidebar\"><!-- contentplaceholder: sidebar --></div>\n<div class=\"article\"><!-- contentplaceholder: article --></div>\n\n<!-- target: myTarget(master=myMaster) -->\n<!-- content: title -->\nBuilding WebKit from Xcode\n<!-- content: main -->\n<p>To build from within Xcode, you can use the WebKit workspace. </p>\n\n<!-- target: myTarget-has-sidebar(master=myMaster-has-sidebar) -->\n<!-- content: sidebar -->\n<ul class=\"navigator\">...</ul>\n<!-- content: article -->\n<p>To build from within Xcode, you can use the WebKit workspace. </p>\n```\n\n##### 自动结束\n\nmaster支持自动结束，当遇见 *target* 或 *master* 时自动结束。\n\ncontentplaceholder支持自动结束，当遇见 *contentplaceholder* 或 *target* 或 *master* 时，在`指令标签起始`后自动结束。\n\ncontent支持自动结束，当遇见 *content* 或 *target* 或 *master* 时自动结束。\n\n\n#### use\n\n通过`use`指令，可以调用指定`target`，在当前位置插入其render后的结果。允许使用静态或动态数据指定数据项。\n\n##### 语法\n\nuse的语法形式为：\n\n    use: target-name\n    use: target-name(data-name=expression, data-name=expression)\n\n\n##### 示例\n\n```html\n<!-- target: info -->\nname: ${name}\n<!-- if: ${email} -->\nemail: ${email}\n<!-- /if -->\n\n<!-- target: main -->\n<div class=\"main\"><!-- use: info(name=${person.name}, email=${person.email}) --></div>\n```\n\n##### 自动结束\n\nuse无需编写`指令结束`，其将在`指令起始`后立即自动结束。\n\n### 分支与循环\n\n#### if\n\nETPL提供了分支的支持，相关指令有`if`、`elif`、`else`。\n\n##### 语法\n\nif的语法形式为：\n\n    if: conditional-expression\n\nelif的语法形式为：\n\n    elif: conditional-expression\n\nelse的语法形式为：\n\n    else\n\nconditional-expression中可以使用动态数据，通过`${variable}`的形式，可以使用模板render的data。`${variable}`支持`.`的property accessor。\n\n##### 自动结束\n\nif指令不支持自动结束，必须手工编写指令结束`<!-- /if -->`。\n\n##### 示例\n\n```html\n<!-- if: ${number} > 0 -->\nlarger than zero\n<!-- elif: ${number} == 0 -->\nzero\n<!-- else -->\ninvalid\n<!-- /if -->\n```\n\n##### 自动结束\n\nif指令不支持自动结束，必须手工编写`指令结束`。\n\n```html\n<!-- /if -->\n```\n\n#### for\n\n通过for指令的支持，可以实现对Array和Object的遍历。Array为正序遍历，Object为不保证顺序的forin。\n\n##### 语法\n\nfor的语法形式为：\n\n    for: ${variable} as ${item-variable}\n    for: ${variable} as ${item-variable}, ${index-variable}\n    for: ${variable} as ${item-variable}, ${key-variable}\n\n其中，`${variable}`为想要遍历的对象，支持`.`形式的property access。在遍历过程中，声明的`${item-variable}`和`${index-variable}`，分别代表数据项和索引（遍历Object时为键名）。\n\n##### 示例\n\n```html\n<ul>\n<!-- for: ${persons} as ${person}, ${index} -->\n<li>${index}: ${person.name}\n<!-- /for -->\n</ul>\n```\n\n##### 自动结束\n\nfor指令不支持自动结束，必须手工编写`指令结束`。\n\n```html\n<!-- /for -->\n```\n\n## API\n\n### methods\n\nETPL初始化时自动创建一个默认的引擎实例，并将其暴露。大多数应用场景可直接使用默认的引擎实例。\n\n```javascript\nvar etpl = require( 'etpl' );\n```\n\n##### {void} addFilter( {string}name, {function({string}, {...*}):string}filter )\n\n为默认引擎添加过滤器。过滤函数的第一个参数为过滤源字符串，其后的参数可由模板开发者传入。过滤函数必须返回string。\n\n- `{string}`name - 过滤器名称\n- `{Function}`filter - 过滤函数\n\n```javascript\netpl.addFilter( 'markdown', function ( source, useExtra ) {\n    // ......\n} );\n```\n\n##### {Function} compile( {string}source )\n\n使用默认引擎编译模板。返回第一个target编译后的renderer函数。\n\n- `{string}`source - 模板源代码\n\n```javascript\nvar helloRenderer = etpl.compile( 'Hello ${name}!' );\nhelloRenderer( {name: 'ETPL'} ); // Hello ETPL!\n```\n\n##### {void} config( {Object}options )\n\n对默认引擎进行配置，配置参数将合并到引擎现有的参数中。\n\n- `{Object}`options - 配置参数对象\n- `{string}`options.commandOpen - 命令语法起始串，默认值为 *<!--*\n- `{string}`options.commandClose - 命令语法结束串，默认值为 *-->*\n- `{string}`options.defaultFilter - 默认变量替换的filter，默认值为 *html*\n- `{boolean}`options.strip - 是否清除命令标签前后的空白字符，默认值为 *false*\n- `{string}`options.namingConflict - target或master名字冲突时的处理策略，值可以是`error` | `ignore` | `override`，分别代表`抛出错误`、`保留现有目标，忽略新目标`、`覆盖现有目标`。默认值为 *error*\n\n```javascript\netplEngine.config( {\n    defaultFilter: ''\n} );\n```\n\n##### {string} get( {string}name )\n\n从默认引擎中，根据target名称获取模板内容。\n\n- `{string}`name - target名称\n\n```javascript\netpl.compile( '<!-- target: hello -->Hello ${name}!' );\netpl.get( 'hello' ); // Hello ${name}!\n```\n\n\n\n##### {Function} getRenderer( {string}name )\n\n从默认引擎中，根据target名称获取编译后的renderer函数。\n\n- `{string}`name - target名称\n\n```javascript\netpl.compile( '<!-- target: hello -->Hello ${name}!' );\nvar helloRenderer = etpl.getRenderer( 'hello' );\nhelloRenderer( {name: 'ETPL'} ); // Hello ETPL!\n```\n\n##### {Function} parse( {string}source )\n\n同`compile`方法。该方法的存在是为了兼容老版本的模板引擎api，不建议使用。\n\n\n\n##### {string} render( {string}name, {Object}data )\n\n使用默认引擎执行模板渲染，返回渲染后的字符串。\n\n- `{string}`name - target名称\n- `{Object}`data - 模板数据。可以是plain object，也可以是带有 **{string}get({string}name)** 方法的对象\n\n```javascript\netpl.compile( '<!-- target: hello -->Hello ${name}!' );\netpl.render( 'hello', {name: 'ETPL'} ); // Hello ETPL!\n```\n\n### classes\n\n\n#### Engine\n\n*不同的引擎实例可有效避免target命名冲突的问题。*\n\n##### 初始化\n\n下面的代码可以初始化一个新的引擎实例。\n\n```javascript\nvar etpl = require( 'etpl' );\nvar etplEngine = new etpl.Engine();\n```\n\n引擎实例的初始化允许传入引擎参数。支持的引擎参数见下面的`config`方法。\n\n```javascript\nvar etpl = require( 'etpl' );\nvar etplEngine = new etpl.Engine({\n    commandOpen: '<%',\n    commandClose: '%>'\n});\n```\n\n##### {void} addFilter( {string}name, {function({string}, {...*}):string}filter )\n\n添加过滤器。过滤函数的第一个参数为过滤源字符串，其后的参数可由模板开发者传入。过滤函数必须返回string。\n\n- `{string}`name - 过滤器名称\n- `{Function}`filter - 过滤函数\n\n```javascript\netplEngine.addFilter( 'markdown', function ( source, useExtra ) {\n    // ......\n} );\n```\n\n##### {Function} compile( {string}source )\n\n编译模板。返回第一个target编译后的renderer函数。\n\n- `{string}`source - 模板源代码\n\n```javascript\nvar helloRenderer = etplEngine.compile( 'Hello ${name}!' );\nhelloRenderer( {name: 'ETPL'} ); // Hello ETPL!\n```\n\n##### {void} config( {Object}options )\n\n对引擎进行配置，配置参数将合并到引擎现有的参数中。\n\n- `{Object}`options - 配置参数对象\n- `{string}`options.commandOpen - 命令语法起始串，默认值为 *<!--*\n- `{string}`options.commandClose - 命令语法结束串，默认值为 *-->*\n- `{string}`options.defaultFilter - 默认变量替换的filter，默认值为 *html*\n- `{boolean}`options.strip - 是否清除命令标签前后的空白字符，默认值为 *false*\n- `{string}`options.namingConflict - target或master名字冲突时的处理策略，值可以是`error` | `ignore` | `override`，分别代表`抛出错误`、`保留现有目标，忽略新目标`、`覆盖现有目标`。默认值为 *error*\n\n```javascript\netplEngine.config( {\n    defaultFilter: ''\n} );\n```\n\n##### {string} get( {string}name )\n\n根据target名称获取模板内容。\n\n- `{string}`name - target名称\n\n\n```javascript\netplEngine.compile( '<!-- target: hello -->Hello ${name}!' );\netplEngine.get( 'hello' ); // Hello ${name}!\n```\n\n\n##### {Function} getRenderer( {string}name )\n\n根据target名称获取编译后的renderer函数。\n\n- `{string}`name - target名称\n\n```javascript\netplEngine.compile( '<!-- target: hello -->Hello ${name}!' );\nvar helloRenderer = etplEngine.getRenderer( 'hello' );\nhelloRenderer( {name: 'ETPL'} ); // Hello ETPL!\n```\n\n\n##### {string} render( {string}name, {Object}data )\n\n执行模板渲染，返回渲染后的字符串。\n\n- `{string}`name - target名称\n- `{Object}`data - 模板数据。可以是plain object，也可以是带有 **{string}get({string}name)** 方法的对象\n\n```javascript\netplEngine.compile( '<!-- target: hello -->Hello ${name}!' );\netplEngine.render( 'hello', {name: 'ETPL'} ); // Hello ETPL!\n```\n\n\n## Compatibility\n\nETPL的前身是[ER框架](https://github.com/ecomfe/er)自带的简易模板引擎，其基本与前身保持兼容。但由于一些考虑因素，存在以下一些不兼容的地方。\n\n### merge\n\n出于代码体积和使用频度的考虑，ETPL删除了`merge`API。如果想要该API，请在自己的应用中加入如下代码：\n\n```javascript\n/**\n * 执行模板渲染，并将渲染后的字符串作为innerHTML填充到HTML元素中。\n * 兼容老版本的模板引擎api\n * \n * @param {HTMLElement} element 渲染字符串填充的HTML元素\n * @param {string} name target名称\n * @param {Object=} data 模板数据\n */\netpl.merge = function ( element, name, data ) {\n    if ( element ) {\n        element.innerHTML = this.render( name, data );\n    }\n};\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ecomfe/etpl/issues"
  },
  "_id": "etpl@2.1.0-rc",
  "_shasum": "95b295021cb32321620ede3fcecc2255208d03e2",
  "_from": "etpl@>=2.0.8",
  "_resolved": "https://registry.npmjs.org/etpl/-/etpl-2.1.0-rc.tgz"
}
